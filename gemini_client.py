import google.generativeai as genai
import os
from typing import Dict, Any, Optional
from loguru import logger
from config import AccountConfig, TonalityType, ContentType
import random


class GeminiClient:
    def __init__(self):
        self.api_key = os.getenv("GEMINI_API_KEY")
        if not self.api_key:
            raise ValueError("GEMINI_API_KEY environment variable is required")
        
        genai.configure(api_key=self.api_key)
        self.model = genai.GenerativeModel('gemini-2.0-flash-exp')
        
        # Track recent conversation starters to avoid repetition
        self.recent_starters = []
        self.max_recent_starters = 10
        
        logger.info("Gemini AI client initialized successfully")
    
    def generate_reply(self, tweet_data: Dict[str, Any], account_config: AccountConfig) -> Optional[str]:
        """Generate a contextual reply based on the tweet and account configuration"""
        try:
            prompt = self._build_prompt(tweet_data, account_config)
            
            logger.info(f"Generating reply for tweet from @{account_config.username}")
            logger.debug(f"Prompt: {prompt}")
            
            response = self.model.generate_content(prompt)
            
            if response.text:
                reply = response.text.strip()
                
                # Ensure reply fits within character limit
                if len(reply) > account_config.max_reply_length:
                    reply = reply[:account_config.max_reply_length - 3] + "..."
                
                # Remove any hashtags that might have been generated
                import re
                reply = re.sub(r'#\w+', '', reply).strip()
                
                logger.success(f"Generated reply: {reply}")
                return reply
            else:
                logger.warning("No reply generated by Gemini")
                return None
                
        except Exception as e:
            logger.error(f"Error generating reply with Gemini: {str(e)}")
            return None
    
    def _build_prompt(self, tweet_data: Dict[str, Any], account_config: AccountConfig) -> str:
        """Build the prompt for Gemini based on tweet data and account configuration"""
        
        # Base context
        tweet_text = tweet_data.get('text', '')
        author = tweet_data.get('author_username', '')
        
        # Tonality descriptions
        tonality_descriptions = {
            TonalityType.FRIENDLY: "warm, approachable, and kind",
            TonalityType.PROFESSIONAL: "formal, respectful, and business-like",
            TonalityType.CASUAL: "relaxed, informal, and conversational",
            TonalityType.HUMOROUS: "witty, playful, and light-hearted",
            TonalityType.SUPPORTIVE: "encouraging, empathetic, and helpful",
            TonalityType.ANALYTICAL: "thoughtful, data-driven, and logical",
            TonalityType.ENTHUSIASTIC: "excited, energetic, and passionate"
        }
        
        # Content type descriptions
        content_descriptions = {
            ContentType.QUESTION: "ask thoughtful follow-up questions",
            ContentType.INSIGHT: "share relevant insights or perspectives",
            ContentType.AGREEMENT: "express agreement and build upon their points",
            ContentType.CONSTRUCTIVE_CRITICISM: "offer respectful alternative viewpoints",
            ContentType.APPRECIATION: "show appreciation for their thoughts",
            ContentType.RESOURCE_SHARING: "suggest relevant resources or links"
        }
        
        content_types_str = ", ".join([content_descriptions[ct] for ct in account_config.content_types])
        
        prompt = f"""You are replying to a tweet from @{author}. Here's the tweet:

"{tweet_text}"

Reply Guidelines:
- Tone: Be {tonality_descriptions[account_config.tonality]}
- Content approach: {content_types_str}
- Max length: {account_config.max_reply_length} characters
- Style: Write as a knowledgeable person engaging in the conversation

{f"Special instructions: {account_config.custom_instructions}" if account_config.custom_instructions else ""}

{f"Avoid these keywords/topics: {', '.join(account_config.avoid_keywords)}" if account_config.avoid_keywords else ""}

Important rules:
1. Keep it concise and engaging
2. Don't use quotes around your reply
3. Make it feel natural and conversational
4. Don't be overly promotional or salesy
5. Focus on adding value to the conversation
6. Don't repeat what they already said
7. Make sure your reply stands alone and makes sense
8. NEVER use hashtags (#) - absolutely no hashtags allowed
9. Do not include any # symbols in your response
10. VARY your conversation starters - avoid repetitive patterns like always starting with "Interesting!"
11. Use diverse openings: direct questions, observations, agreements, building on points, sharing experiences, STATEMENTS
12. DON'T make every reply a question - mix in confident statements, observations, and insights
13. Add subtle web3/crypto style when appropriate ("gm", "wagmi", "based", "this is the way") but keep it professional
14. Sound human and spontaneous, not formulaic or robotic
15. Match the energy and style of the original tweet
16. Be authentic - sometimes be brief, sometimes elaborate, sometimes curious, sometimes supportive

Generate a single reply (no quotes, no extra text, no hashtags):"""
        
        return prompt
    
    def should_reply_to_tweet(self, tweet_data: Dict[str, Any], account_config: AccountConfig) -> bool:
        """Determine if we should reply to this tweet based on various factors"""
        try:
            tweet_text = tweet_data.get('text', '').lower()
            
            # Check for avoid keywords
            if account_config.avoid_keywords:
                for keyword in account_config.avoid_keywords:
                    if keyword.lower() in tweet_text:
                        logger.info(f"Skipping tweet due to avoid keyword: {keyword}")
                        return False
            
            # Apply reply probability
            if random.random() > account_config.reply_probability:
                logger.info(f"Skipping tweet due to reply probability ({account_config.reply_probability})")
                return False
            
            # Additional filtering logic can be added here
            # e.g., tweet engagement metrics, time since posted, etc.
            
            return True
            
        except Exception as e:
            logger.error(f"Error in should_reply_to_tweet: {str(e)}")
            return False
