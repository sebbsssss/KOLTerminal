import google.generativeai as genai
import os
from typing import Dict, Any, Optional
from loguru import logger
from config import AccountConfig, TonalityType, ContentType
import random


class GeminiClient:
    def __init__(self):
        self.api_key = os.getenv("GEMINI_API_KEY")
        if not self.api_key:
            raise ValueError("GEMINI_API_KEY environment variable is required")
        
        genai.configure(api_key=self.api_key)
        self.model = genai.GenerativeModel('gemini-2.0-flash-exp')
        
        # Track recent conversation starters to avoid repetition
        self.recent_starters = []
        self.max_recent_starters = 10
        
        logger.info("Gemini AI client initialized successfully")
    
    def generate_reply(self, tweet_data: Dict[str, Any], account_config: AccountConfig) -> Optional[str]:
        """Generate a contextual reply based on the tweet and account configuration"""
        try:
            prompt = self._build_prompt(tweet_data, account_config)
            
            logger.info(f"Generating reply for tweet from @{account_config.username}")
            logger.debug(f"Prompt: {prompt}")
            
            response = self.model.generate_content(prompt)
            
            if response.text:
                reply = response.text.strip()
                
                # Ensure reply fits within character limit
                if len(reply) > account_config.max_reply_length:
                    reply = reply[:account_config.max_reply_length - 3] + "..."
                
                # Remove any hashtags that might have been generated
                import re
                reply = re.sub(r'#\w+', '', reply).strip()
                
                logger.success(f"Generated reply: {reply}")
                return reply
            else:
                logger.warning("No reply generated by Gemini")
                return None
                
        except Exception as e:
            logger.error(f"Error generating reply with Gemini: {str(e)}")
            return None
    
    def _build_prompt(self, tweet_data: Dict[str, Any], account_config: AccountConfig) -> str:
        """Build the prompt for Gemini based on tweet data and account configuration"""
        
        # Base context
        tweet_text = tweet_data.get('text', '')
        author = tweet_data.get('author_username', '')
        
        # Tonality descriptions
        tonality_descriptions = {
            TonalityType.FRIENDLY: "warm, approachable, and kind",
            TonalityType.PROFESSIONAL: "formal, respectful, and business-like",
            TonalityType.CASUAL: "relaxed, informal, and conversational",
            TonalityType.HUMOROUS: "witty, playful, and light-hearted",
            TonalityType.SUPPORTIVE: "encouraging, empathetic, and helpful",
            TonalityType.ANALYTICAL: "thoughtful, data-driven, and logical",
            TonalityType.ENTHUSIASTIC: "excited, energetic, and passionate"
        }
        
        # Content type descriptions
        content_descriptions = {
            ContentType.QUESTION: "ask thoughtful follow-up questions",
            ContentType.INSIGHT: "share relevant insights or perspectives",
            ContentType.AGREEMENT: "express agreement and build upon their points",
            ContentType.CONSTRUCTIVE_CRITICISM: "offer respectful alternative viewpoints",
            ContentType.APPRECIATION: "show appreciation for their thoughts",
            ContentType.RESOURCE_SHARING: "suggest relevant resources or links"
        }
        
        content_types_str = ", ".join([content_descriptions[ct] for ct in account_config.content_types])
        
        prompt = f"""Hey, so @{author} just tweeted this:

"{tweet_text}"

You're gonna reply to them, and here's the vibe we're going for:
- Keep it {tonality_descriptions[account_config.tonality]} - think coffee shop conversation, not boardroom presentation
- Your approach: {content_types_str}
- Don't go over {account_config.max_reply_length} characters (Twitter's not writing a novel here)
- Sound like someone who actually knows their stuff but isn't trying to prove it

{f"Oh, and here's some specific stuff to keep in mind: {account_config.custom_instructions}" if account_config.custom_instructions else ""}

{f"Definitely steer clear of: {', '.join(account_config.avoid_keywords)}" if account_config.avoid_keywords else ""}

Alright, here's how to nail this reply:
• Keep it snappy but meaningful - nobody wants a dissertation
• Skip the quotes around your response (just write naturally)
• Make it sound like you're actually talking to a person, not reciting a script
• Don't be that person who's obviously trying to sell something
• Add something useful to the conversation - build on what they said
• Don't just parrot back what they already wrote (we all read the original tweet)
• Your reply should make sense even if someone didn't see the original
• No hashtags whatsoever - seriously, none. Not even one little #
• Mix up how you start replies - "Interesting!" gets old fast. Try observations, agreements, building on their point, sharing quick insights, or just confident takes
• Never end with questions - make statements instead. Instead of "What do you think?" try "Here's how I see it" or just state your perspective directly
• Turn question marks into periods and rephrase as confident observations
• Throw in some web3 flavor when it fits ("gm", "wagmi", "based", "this is the way") but don't force it
• Sound human and spontaneous - sometimes short and sweet, sometimes you elaborate a bit, but always confident
• Match their energy - if they're excited, you can be too. If they're chill, keep it relaxed
• Be real - authenticity beats perfection every time

Just write one solid reply (no quotes, no extra stuff, definitely no hashtags):"""
        
        return prompt
    
    def should_reply_to_tweet(self, tweet_data: Dict[str, Any], account_config: AccountConfig) -> bool:
        """Determine if we should reply to this tweet based on various factors"""
        try:
            tweet_text = tweet_data.get('text', '').lower()
            
            # Check for avoid keywords
            if account_config.avoid_keywords:
                for keyword in account_config.avoid_keywords:
                    if keyword.lower() in tweet_text:
                        logger.info(f"Skipping tweet due to avoid keyword: {keyword}")
                        return False
            
            # Apply reply probability
            if random.random() > account_config.reply_probability:
                logger.info(f"Skipping tweet due to reply probability ({account_config.reply_probability})")
                return False
            
            # Additional filtering logic can be added here
            # e.g., tweet engagement metrics, time since posted, etc.
            
            return True
            
        except Exception as e:
            logger.error(f"Error in should_reply_to_tweet: {str(e)}")
            return False
